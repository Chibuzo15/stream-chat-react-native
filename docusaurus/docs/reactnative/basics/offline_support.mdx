---
id: offline-support
sidebar_position: 4
title: Offline Support
---

Stream Chat for React Native enables offline support by exposing a class called `StreamCache`. This allows using any storage provider with Stream.
The constructor requires a client, a `cacheInterface` object containing `getItem`, `setItem` and `removeItem` properties and a
token or token provider function.

## Creating a cache interface

First, create the `cacheInterface` object.

```ts

import AsyncStorage from '@react-native-community/async-storage';
import { CacheKeys, CacheValues } from 'stream-chat-react-native';

// Your custom types
import type {
  LocalAttachmentType,
  LocalChannelType,
  LocalCommandType,
  LocalEventType,
  LocalMessageType,
  LocalReactionType,
  LocalUserType,
  LoginConfig,
} from '../types';

const cacheInterface: CacheInterface<
      LocalAttachmentType,
      LocalChannelType,
      LocalCommandType,
      LocalMessageType,
      LocalReactionType,
      LocalUserType
    > = {
      getItem: (key) => AsyncStore.getItem(key, null),
      removeItem: (key) => AsyncStore.removeItem(key),
      setItem: (key, value) => AsyncStore.setItem(key, value),
    };

```

### Cache interface with synchronous storage providers

Once we need to support both synchronous and asynchronous storage providers, you need to wrap the return values of your cache 
interface into promises.

```ts

import { MMKV } from 'react-native-mmkv';
import { CacheKeys, CacheValues } from 'stream-chat-react-native';

// Your custom types
import type {
  LocalAttachmentType,
  LocalChannelType,
  LocalCommandType,
  LocalEventType,
  LocalMessageType,
  LocalReactionType,
  LocalUserType,
  LoginConfig,
} from '../types';

const cacheInterface: CacheInterface<
      LocalAttachmentType,
      LocalChannelType,
      LocalCommandType,
      LocalMessageType,
      LocalReactionType,
      LocalUserType
    > = {
    getItem: (key) => {
        const value = MMKV.getString(key)

        if (!value) {
            return Promise.resolve(null);
        }

        return Promise.resolve(JSON.parse(value) as CacheValues[Key]);
    },
    removeItem: (key) => {
        return Promise.resolve(MMKV.delete(key));
    },
    setItem: (key, value) => {
        return Promise.resolve(MMKV.set(key, JSON.stringify(value)));
    },
};

```

## Initializing the client with cached data

Now, you need to initialize the cache. Please have in mind that you still need to handle authentication by yourself by passing a token or
a token provider function as third parameter. 

:::info

If you use tokens without expiration date, just store/retrieve the token from your storage provider and send it to StreamCache.

If you use tokens with expiration date, have a look at our client documentation on 
[how to refresh expired tokens](https://getstream.io/chat/docs/react-native/tokens_and_authentication/?language=javascript&q=authen#how-to-refresh-expired-tokens)

:::

```ts

...
import { CacheKeys, CacheValues, StreamCache } from 'stream-chat-react-native';

const client = StreamChat.getInstance(api_key) // Your current client setup
const cacheInterface = { /** Your cache interface, as described in previous step */ }

function App() {
    const [ready, setReady] = useState(false);

    const initializeApp = useCallback(async () => {
        const config = // Your logics to get auth data
        const cacheInstance = StreamCache.getInstance(client, cacheInterface, config.userToken);

        if (await cacheInstance.hasCachedData()) {
            console.info('Found cached data. Initializing cache...');
            // initialize already takes care of calling connectUser internally
            await cacheInstance.initialize();
        } else {
            console.info('No cache data found. Skipping cache initialization...');

            const user = {
                id: config.userId,
                image: config.userImage,
                name: config.userName,
            };

            // In case there is no cache, you need to authenticate by calling connectUser.
            await client.connectUser(user, config.userToken);
        }
    }, [])

    useEffect(() => {
        initializeApp(config);
    }, [])

    return ready && (
        <Chat client={client}>
          // Stream chat components
        </Chat>
    );
}

```

## Clearing cache

If you want to clear the cache, you can just call `StreamCache.getInstance().clear()` or `StreamMediaCache.clear()` in case 
you only want to clear cached media. StreamCache's clear method already takes care of clearing the StreamMediaCache.

## Custom components & offline support

If you're using your own custom components/hooks, you may need to pay attention to check if you're customizing any of the key
components/hooks we use to make the offline support work. In order to make things easier for you, the package is exposing some
lower level methods and components that you can easily use in order to make your components work offline.

:::note

If you're not adding customizations to any of the following components/hooks, please ignore this step.

:::

### usePaginatedChannel

Not a component, but if you're using your own hook to fetch the `channel list` items, you may need to have a look at our
[usePaginatedChannel]() hook. The secret is basically adding an `useEffect` with your channels as dependency so you can
update the stored channels order everytime it changes.

```ts

    const cacheInstance = StreamCache.hasInstance()
    ? StreamCache.getInstance()
    : null;

    // If cache is instantiated, get ordered channels from it. Otherwise use empty array.
    const [channels, setChannels] = useState(() =>
        cacheInstance ? cacheInstance.getOrderedChannels(filters, sort) : [],
    );

    // If cache is instantiated, update channels cached order everytime channels array changes.
    useEffect(() => {
        if (cacheInstance) {
        cacheInstance.syncChannelsCachedOrder(channels, filters, sort);
        }
  }, [channels]);

```

### Attachments `Image`

Our attachment components use React Native's default Image component to render image attachments
in the chat. If you're adding any kind of customizations to the attachments, please have in mind that
you're supposed to replace all `Images` with our `CachedAttachmentImage`.

### Gallery `ImageBackground`

Our gallery components use React Native's default ImageBackground component internally. If you've made
any kind of customizations to the gallery, please have in mind that you should replace your `ImageBackground`
component with our `CachedImageBackground`.