---
id: offline-support
sidebar_position: 4
title: Offline Support
---

Stream Chat for React Native enables offline support by exposing a class called `StreamCache`. This allows using any storage provider with Stream.
The constructor requires a client, a `cacheInterface` object containing `getItem`, `setItem` and `removeItem` properties and a
token or token provider function.

## Creating a cache interface

First, create the `cacheInterface` object.

```ts

import AsyncStorage from '@react-native-community/async-storage';
import { CacheKeys, CacheValues } from 'stream-chat-react-native';

// Your custom types
import type {
  LocalAttachmentType,
  LocalChannelType,
  LocalCommandType,
  LocalEventType,
  LocalMessageType,
  LocalReactionType,
  LocalUserType,
  LoginConfig,
} from '../types';

const cacheInterface: CacheInterface<
      LocalAttachmentType,
      LocalChannelType,
      LocalCommandType,
      LocalMessageType,
      LocalReactionType,
      LocalUserType
    > = {
      getItem: (key) => AsyncStore.getItem(key, null),
      removeItem: (key) => AsyncStore.removeItem(key),
      setItem: (key, value) => AsyncStore.setItem(key, value),
    };

```

### Cache interface with synchronous storage providers

Once we need to support both synchronous and asynchronous storage providers, you need to wrap the return values of your cache 
interface into promises.

```ts

import { MMKV } from 'react-native-mmkv';
import { CacheKeys, CacheValues } from 'stream-chat-react-native';

// Your custom types
import type {
  LocalAttachmentType,
  LocalChannelType,
  LocalCommandType,
  LocalEventType,
  LocalMessageType,
  LocalReactionType,
  LocalUserType,
  LoginConfig,
} from '../types';

const cacheInterface: CacheInterface<
      LocalAttachmentType,
      LocalChannelType,
      LocalCommandType,
      LocalMessageType,
      LocalReactionType,
      LocalUserType
    > = {
    getItem: (key) => {
        const value = MMKV.getString(key)

        if (!value) {
            return Promise.resolve(null);
        }

        return Promise.resolve(JSON.parse(value) as CacheValues[Key]);
    },
    removeItem: (key) => {
        return Promise.resolve(MMKV.delete(key));
    },
    setItem: (key, value) => {
        return Promise.resolve(MMKV.set(key, JSON.stringify(value)));
    },
};

```

## Initializing the client with cached data

Now, you need to initialize the cache. Please have in mind that you still need to handle authentication by yourself by passing a token or
a token provider function as third parameter. 

:::info

If you use tokens without expiration date, just store/retrieve the token from your storage provider and send it to StreamCache.

If you use tokens with expiration date, have a look at our client documentation on 
[how to refresh expired tokens](https://getstream.io/chat/docs/react-native/tokens_and_authentication/?language=javascript&q=authen#how-to-refresh-expired-tokens)

:::

```ts

...
import { CacheKeys, CacheValues, StreamCache } from 'stream-chat-react-native';

const client = StreamChat.getInstance(api_key) // Your current client setup
const cacheInterface = { /** Your cache interface, as described in previous step */ }

function App() {
    const [ready, setReady] = useState(false);

    const initializeApp = useCallback(async () => {
        const config = // Your logics to get auth data
        const cacheInstance = StreamCache.getInstance(client, cacheInterface, config.userToken);

        if (await cacheInstance.hasCachedData()) {
            console.info('Found cached data. Initializing cache...');
            // initialize already takes care of calling connectUser internally
            await cacheInstance.initialize();
        } else {
            console.info('No cache data found. Skipping cache initialization...');

            const user = {
                id: config.userId,
                image: config.userImage,
                name: config.userName,
            };

            // In case there is no cache, you need to authenticate by calling connectUser.
            await client.connectUser(user, config.userToken);
        }
    }, [])

    useEffect(() => {
        initializeApp(config);
    }, [])

    return ready && (
        <Chat client={client}>
          // Stream chat components
        </Chat>
    );
}

```
